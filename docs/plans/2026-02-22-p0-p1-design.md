# P0 + P1 Gap Closure — Design Document

**Date**: 2026-02-22
**Scope**: Production storage backends, vector search, CI/CD, WebSocket fix, auth, security, API completeness
**PRD Ref**: `docs/KnowledgePulse_PRD_v1.1.md` Sections 3.4–3.5, 4.1, 5.2, 6
**Gap Analysis**: `docs/gap-analysis-phase1-4.md`

---

## 1. Infrastructure & Connections

### PostgreSQL
- **Host**: `172.31.9.157:5432` (internal IP)
- **Database**: `knowledgepulse`
- **User**: `knowledgepulse_user`
- **Connection string**: `postgresql://knowledgepulse_user:KPulse2026Secure@172.31.9.157:5432/knowledgepulse`
- **Extensions**: `uuid-ossp` enabled

### Redis
- **Host**: `localhost:6379` (db0)
- **Password**: configured
- **Prefix**: `kp:` (all keys namespaced to isolate from other services)

### Zvec (Vector DB — Qdrant replacement)
- **Package**: `@zvec/zvec` on npm
- **Mode**: Embedded in-process (no separate server)
- **Rationale**: Matches Bun+SQLite embedded pattern, native hybrid search with RRF, 8000+ QPS on 10M vectors

---

## 2. Storage Backend Architecture

### Adapter Pattern via Existing Factory

The codebase already has `AllStores` interface + `createStore()` factory. Extend with:

```
registry/src/store/
  interfaces.ts          # (existing, unchanged)
  factory.ts             # extend switch: "postgres" case
  memory/                # (existing, unchanged)
  sqlite/                # (existing, unchanged)
  postgres/              # NEW — all 9 store interfaces via pg
    db.ts                # connection pool + DDL migration
    skill-store.ts
    knowledge-store.ts
    reputation-store.ts
    apikey-store.ts
    sop-store.ts
    credit-store.ts
    marketplace-store.ts
    rate-limit-store.ts  # fallback if Redis unavailable
    audit-log-store.ts   # NEW (missing even in SQLite)
    index.ts             # createPostgresStore()
  redis/                 # NEW — ephemeral/high-frequency stores
    client.ts            # ioredis connection with kp: prefix
    rate-limit-store.ts  # Redis-backed token bucket
    cache.ts             # query result cache (TTL-based)
    index.ts
```

### Design Decisions

1. **PostgreSQL** for durable stores (skills, knowledge, reputation, api_keys, sops, credits, marketplace, audit_log)
2. **Redis** for ephemeral stores (rate limiting, query cache) with `kp:` prefix isolation
3. **Hybrid AllStores**: PG for 8 stores + Redis for `RateLimitStore` — composed in factory
4. **Fix index.ts**: Replace hard-coded `createMemoryStore()` with `await createStore()` factory call
5. **JSONB columns** for KnowledgeUnit, ExpertSOP, history arrays — enabling GIN-indexed queries
6. **Connection pooling** via `pg` npm package with configurable pool size

### Environment Variables

```bash
KP_STORE_BACKEND=postgres
KP_DATABASE_URL=postgresql://knowledgepulse_user:KPulse2026Secure@172.31.9.157:5432/knowledgepulse
KP_REDIS_URL=redis://:bibi5566778800@localhost:6379/0
KP_REDIS_PREFIX=kp:
```

### PostgreSQL Schema

Key differences from SQLite:
- `JSONB` instead of `TEXT` for structured data (unit, sop, history, tags, scopes, votes)
- Native `BOOLEAN` instead of `INTEGER 0/1`
- `BIGINT` for millisecond timestamps in rate_limit tables
- GIN indexes on JSONB columns for efficient filtering on `metadata.agent_id`, `@type`, `domain`
- `TIMESTAMPTZ` for all temporal columns

---

## 3. Zvec Vector Search Integration

### Architecture: Embedded Library Alongside PostgreSQL

```
registry/src/store/zvec/
  client.ts              # Zvec collection init + schema definition
  vector-search.ts       # VectorSearchProvider interface + Zvec impl
  index.ts               # createVectorSearch() factory
```

### Data Flow for Search

1. **Zvec** handles vector similarity (semantic embedding search) → returns candidate IDs + scores
2. **PostgreSQL** handles structured filtering (domain, types, quality, visibility, pagination)
3. Registry search combines both: Zvec candidates → PostgreSQL metadata join + filter

### Collections

- `kp_skills` — skill embeddings (from name + description)
- `kp_knowledge` — knowledge unit embeddings (from task objective + step contents)

### Hybrid Search (fulfills P1-1)

Zvec's native hybrid search with Reciprocal Rank Fusion satisfies PRD Section 4.1's "vector semantic + BM25 keyword hybrid search" requirement. Dense + sparse vector support enables combined semantic and keyword scoring in a single query.

---

## 4. CI/CD — GitHub Actions

```
.github/workflows/ci.yml
```

### Pipeline

- **Triggers**: push to `main`, all PRs
- **Jobs**:
  1. `lint` — `bunx biome check`
  2. `typecheck` — `bunx tsc --noEmit`
  3. `test` — `bun test --recursive`
  4. `codegen` — `bun run codegen` + `git diff --exit-code` (schema consistency)
  5. `build` — `bun run build`
- No deployment — quality gates only

---

## 5. WebSocket Broadcast Fix

### Current Issue
`registry/src/routes/ws-collaborate.ts` — `CollaborationManager` tracks peers but WS handler only echoes back to sender. No multi-peer broadcast.

### Fix
- Extend `CollaborationManager` to hold `Set<ServerWebSocket>` per room
- On `message`: iterate room WS set, `send()` to all peers except sender
- On `close`: remove socket from set, broadcast leave to remaining peers
- Small focused change, no architecture change

---

## 6. JWT/OIDC Authentication (P1-2)

### New Middleware
`registry/src/middleware/jwt-auth.ts`

### Config
```bash
KP_OIDC_ISSUER=https://your-idp.example.com
KP_OIDC_AUDIENCE=knowledgepulse-api
KP_OIDC_JWKS_URL=https://your-idp.example.com/.well-known/jwks.json
```

### Behavior
- Uses `jose` npm package for JWKS fetching + JWT verification
- JWT claims map to existing auth context: `agent_id`, `org_id`, `scopes[]`, `kp_rep_score`
- Falls through to API Key auth if no Bearer JWT present → backward compatible
- Env vars optional — JWT auth disabled when not configured

---

## 7. LLM Injection Classifier (P1-3)

### Location
`packages/sdk/src/utils/injection-classifier.ts`

### Strategy
Pattern-based heuristic classifier (no external LLM call):
- Known injection patterns (system prompt overrides, role-play attacks, delimiter escapes)
- Hidden instruction detection (HTML comments, Unicode steganography — extending existing sanitizer)
- Scoring model: each pattern match adds to risk score; reject above configurable threshold
- Runs once at SKILL.md import time, not per query

### Integration
Called from `sanitizeSkillMd()` as an additional check layer, returning risk assessment in `SanitizeResult`.

---

## 8. Provider Discovery (P1-4)

### REST Endpoint
`GET /v1/providers` — returns list of known KP registry nodes

### MCP Tool
`kp_provider_discover` — wraps the REST endpoint

### Storage
New `providers` table in PostgreSQL (id, url, name, status, last_heartbeat, registered_at).
New `ProviderStore` interface + implementations.

---

## 9. OpenAPI Spec (P1-5)

### Output
`specs/api-openapi.yaml` — OpenAPI 3.1 specification

### Approach
Hand-written from existing Hono route definitions + Zod schemas. Covers all registry endpoints with request/response schemas.

---

## 10. `kp list` CLI Command (P1-6)

### Behavior
- Scans `~/.claude/skills/` directory for `.md` files
- Parses SKILL.md frontmatter (name, version, domain, tags)
- Displays table of installed skills
- `--json` flag for machine-readable output

---

## 11. Idempotency Key Enforcement (P1-7)

### Redis-backed
- Key pattern: `kp:idempotency:<key>` with 24h TTL
- Middleware on all POST/PUT endpoints
- Header: `Idempotency-Key: <uuid>`
- First request: execute + cache response
- Duplicate request: return cached response with `Idempotency-Replayed: true` header

---

## 12. MCP Session Token Auth (P1-8)

### Behavior
- MCP server creates session on first handshake
- Client provides API key during session init → stored as session-to-key mapping
- Subsequent MCP tool calls authenticated via session token lookup → resolves to API key
- Session expires after configurable TTL (default 1h)
- Storage: Redis `kp:mcp-session:<token>` with TTL

---

## Implementation Sequence

1. **PostgreSQL adapter** (P0-2) — all 9 stores + DDL migration + fix factory
2. **Redis adapter** (P0-3) — rate limit store + cache + idempotency (P1-7)
3. **Zvec spike + integration** (P0-4 + P1-1) — install, test, build store
4. **WebSocket broadcast fix** (P0-6)
5. **JWT/OIDC middleware** (P1-2)
6. **Injection classifier** (P1-3)
7. **Provider discovery** (P1-4) — endpoint + MCP tool
8. **MCP session token auth** (P1-8)
9. **`kp list` command** (P1-6)
10. **OpenAPI spec** (P1-5)
11. **GitHub Actions CI/CD** (P0-5)

---

*Approved: 2026-02-22*
